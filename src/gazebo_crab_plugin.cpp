/*
// ROS headers
#include <ros/ros.h>
#include <std_msgs/Float64.h>
#include <dynamic_reconfigure/server.h>
#include <gazebo_crab_plugin/dyn_paramsConfig.h>		// auto-generated, based on ../cfg/dyn_params.cfg

// header, as sugested in http://wiki.gazebosim.org/wiki/Tutorials/1.9/Creating_ROS_plugins_for_Gazebo
//#include <gazebo/common/Plugin.hh>

// GAZEBO headers
// headers, as sugested in http://gazebosim.org/tutorials?tut=plugins_model&cat=write_plugin
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <control_toolbox/pid.h>

#include <gazebo_crab_plugin/pid_joint_state.h>		// auto-generated by the project, based on msg/pid_joint_state.msg

// C++ headers
#include <stdio.h>

// BOOST headers
#include <boost/bind.hpp>
*/

#include "../include/gazebo_crab_plugin/gazebo_crab_plugin.hpp"
#include <sstream>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <boost/filesystem.hpp>


namespace gazebo {
	
	
	
	// forward declaration for the callback function
	class PidJoint;
	// dynamic reconfigure callback function for the PidJoint class
	void callback( gazebo_crab_plugin::dyn_paramsConfig &config, uint32_t level, PidJoint *pid_joint );
	
	
	
	
	class PidJoint {
		public:
			PidJoint( ModelPIDJoint *parent, gazebo::physics::Joint &joint ) :
				ready_(false), joint_(&joint), desired_value_(0), save_to_file_(false),
				past_index_(0), joint_velocity_(0), joint_max_force_(5.0), joint_max_velocity_(2*M_PI),
				joint_desired_velocity_(0), joint_delta_force_(0), joint_angle_(0), joint_force_(0),
				update_type_(1), input_type_(0), reset_(false) {
				
				parent_ = parent;
				nh_ = parent_->getNH();
				// load some default values. the real values (possibly default defined in the cfg file) are loaded
				// through the dynamic reconfigure callback
				if( joint_->GetName() == "joint_3" ) {
					pid_.initPid( 0.275515, 0.000757, 0.04958, 0.1, -0.1 );
					joint_max_velocity_ = 0.0124;
					velocity_damping_ = 0.0045;
				} else {
					pid_.initPid( 0.1724, 0.0011, 0.02, 0.04, -0.04 );
					joint_max_velocity_ = 0.990884;
					velocity_damping_ = 0.0890248;
				}
				
				ros::NodeHandle dyn_nh = ros::NodeHandle( *nh_, joint_->GetName() + "_dyn" );
				dyn_reconf_server_ = new dynamic_reconfigure::Server<gazebo_crab_plugin::dyn_paramsConfig>( dyn_nh );
				dynamic_reconfigure::Server<gazebo_crab_plugin::dyn_paramsConfig>::CallbackType f;
				
				f = boost::bind( &callback, _1, _2, this );
				dyn_reconf_server_->setCallback( f );

				
				startup();
			};
			
			/// @brief sets the initial state of the joint and the controller
			void startup() {
				/* disabled for now. a log file will be created when we change the parameters via subParamStrCallback
				if( save_to_file_ ) {
					std::string path = std::string( "/opt/shared/developer/logs/arm_test/" );
					boost::filesystem::path dir(path);
					boost::system::error_code ec;
					boost::filesystem::create_directories(dir, ec);
					if( ec ) {
						//std::cout << "failed to create directory '" << path << "', error=" << ec.message() << std::endl;
						//ROS_ERROR( "failed to create directory '%s'", path.c_str() );
					}
					std::string filename = (std::string("") + (parent_->getNH()->getNamespace().c_str()+1) + "." + joint_->GetName() + ".log");
					log_file_.open( (path+filename).c_str(), std::ios::out );
					std::cout << "log file=" << (path+filename) << std::endl;
				}
				*/
				sub_ = nh_->subscribe< std_msgs::Float64 >( joint_->GetName(), 2, &PidJoint::subCallback, this );
				if( !sub_ )
					std::cout << "failed to subscribe to joint topic for set commands" << std::endl;
				sub_param_ = nh_->subscribe< std_msgs::String >( joint_->GetName()+"_str_param", 2, &PidJoint::subParamStrCallback, this );
				
				// advertise the pid state topic
				pub_ = nh_->advertise< gazebo_crab_plugin::pid_joint_state >( joint_->GetName()+"_pid_state", 10 );
				// advertise the joint error topic
				pub_err_ = nh_->advertise< gazebo_crab_plugin::pid_joint_error >( joint_->GetName()+"_errors", 10 );
					
				time_last_update_ = ros::Time::now();
				pid_.reset();
				past_values_.resize( 4, 0.0 );
				ready_ = true;
			}
			
			/// @brief sets the desired state of the joint in radians (double). assumes a rotary joint with a single axis
			void subCallback( const std_msgs::Float64::ConstPtr &msg ) {
				double data = msg->data;
				
				std::cout << "setting joint " << joint_->GetName() << " to " << data << std::endl;
				
				desired_value_ = data;
			};
			
			/** @brief this function takes a serialized (human-readable string) message and sets the parameters. the parameters
			 *         are expected in a fixed order and are seperated by a single space. the number of parameters is optional.
			 */
			void subParamStrCallback( const std_msgs::String::ConstPtr &msg ) {
				
				std::cout << "setting joint '" << joint_->GetName() << "' params via topic ["
					<< msg->data << "]"
					<< std::endl;
				std::string str = msg->data;
				
				/* field order:
					float64 p_gain
					float64 i_gain
					float64 d_gain
					float64 i_clamp_max
					float64 i_clamp_min
					float64 pid_multiplier
					float64 velocity_max
					float64 velocity_damping
					integer reset (0=no reset, 1=reset joint)
					int32   input_type (0=position, 1=velocity)
					int32   update_type (0=force, 1=delta-force)
				*/
				
				pid_.reset();

				// split string, convert values to doubles
				std::stringstream str_stream( str );
				std::vector<std::string> params;
				std::string element;
				double p, i, d, i_max, i_min;
				int n, reset;
				for( n=0; std::getline(str_stream, element, ' ') && n<8; n++ ) {
					switch( n ) {
						case 0:
							//p = std::stod(element);		// C++11
							p = atof( element.c_str() );
							break;
						case 1:
							i = atof( element.c_str() );
							break;
						case 2:
							d = atof( element.c_str() );
							break;
						case 3:
							i_max = atof( element.c_str() );
							break;
						case 4:
							i_min = atof( element.c_str() );
							std::cout << "setGains(" << p << ", " << i << ", " << d << ", " << i_max << ", " << i_min << ")" << std::endl;
							pid_.setGains( p, i, d, i_max, i_min );
							break;
						case 5:
							pid_multiplier_ = atof( element.c_str() );
							break;
						case 6:
							joint_max_velocity_ = atof( element.c_str() );
							break;
						case 7:
							velocity_damping_ = atof( element.c_str() );
							break;
						case 8:
							reset = atoi( element.c_str() );
							/*
							if( reset ) {
								parent_->resetModel();
								joint_->Reset();
							}
							*/
							break;
						case 9:
							input_type_ = atoi( element.c_str() );
							break;
						case 10:
							update_type_ = atoi( element.c_str() );
							break;
						default:
							// error
							break;
					}
				}
				
				// for testing
				//
				if( reset || true ) {
					reset_ = true;
					//parent_->resetModel();
					//joint_->Reset();
					//joint_->SetVelocity( 0, 0.0 );
					//joint_->SetAngle( 0, 0.0 );
				}
				//
				// end of testing
				
				// open a new file to log the new parameters
				if( save_to_file_ )
					create_file();
				
				/*
				if( log_file_.is_open() && n>4 ) {
					// log fields: time, target_angle, current_angle, velocity, error
					log_file_ << "#" << ros::Time::now()
						<< " " << p
						<< " " << i
						<< " " << d
						<< " " << i_max
						<< " " << i_min
						<< " " << pid_multiplier_
						<< " " << joint_max_velocity_
						<< " " << velocity_damping_
						<< std::endl;
				}
				*/
				
			};
			
			/// @brief sets the desired state of the joint in radians (double). assumes a rotary joint with a single axis
			void subParamCallback( const gazebo_crab_plugin::pid_joint_param::ConstPtr &msg ) {
				
				/*
				std::cout << "setting joint '" << joint_->GetName() << "' params via topic ["
					<< msg->data << "]"
					<< std::endl;
				std::string str = msg->data;
				*/
				
				joint_max_velocity_ = msg->velocity_max;
				velocity_damping_ = msg->velocity_damping;
				pid_multiplier_ = msg->pid_multiplier;
				pid_.setGains( msg->p_gain, msg->i_gain, msg->d_gain, msg->i_clamp_max, msg->i_clamp_min );
				reset_ = msg->reset;
				input_type_ = msg->input_type;
				update_type_ = msg->update_type;
			};
			
			double update_input_pos() {
				double current_angle = joint_->GetAngle( 0 ).Radian();
				double d_angle = desired_value_ - current_angle;
				return d_angle;
			}
			
			double update_input_vel() {
				double current_angle = joint_->GetAngle( 0 ).Radian();
				double d_angle = desired_value_ - current_angle;
				ros::Time now = ros::Time::now();					// current time
				ros::Duration dt = now - time_last_update_;			// delta time (now - last update)
				
				int last_index = past_index_;
				past_index_ = (past_index_ + 1) % past_values_.size();
				past_values_[past_index_] = current_angle;
				joint_velocity_ = past_values_[past_index_] - past_values_[last_index];
				
				// compute our desired velocity
				//   velocity to reach the target angle with the next tick: d_angle / dt
				//   we additionally apply a damping factor, so that we would reach the desired angle in dt/damping_factor seconds (instead of dt seconds)
				double desired_velocity = velocity_damping_ * d_angle / dt.toSec();
				if( desired_velocity > joint_max_velocity_ ) {
					desired_velocity = joint_max_velocity_;
				} else if( desired_velocity < -joint_max_velocity_ ) {
					desired_velocity = -joint_max_velocity_;
				}
				
				double d_vel = desired_velocity - joint_velocity_;			// by what value we want to change the current joint velocity
				
				return d_vel;
			}
			
			/// @brief called to update the joint state according to the PID controller and the desired state
			void update_directForce() {
				ros::Time now = ros::Time::now();
				ros::Duration dt = now - time_last_update_;
				math::Angle joint_angle = joint_->GetAngle( 0 );	// assuming a rotary joint with a single axis/angle
				double current_angle = joint_angle.Radian();
				
				
				
				int last_index = past_index_;
				past_index_ = (past_index_ + 1) % past_values_.size();
				past_values_[past_index_] = current_angle;
				joint_velocity_ = past_values_[past_index_] - past_values_[last_index];
				
				double d_angle = desired_value_ - current_angle;
				double new_force = pid_multiplier_ * pid_.computeCommand( d_angle, dt );
				
				// cap the applied joint force, if it is too large or too small
				if( new_force > joint_max_force_ ) {
					new_force = joint_max_force_;
				} else if( new_force < -joint_max_force_ ) {
					new_force = -joint_max_force_;
				}
				
				// apply force to joint
				joint_->SetForce( 0, new_force );
				
				// save some values that we might publish
				joint_angle_ = current_angle;
				joint_desired_velocity_ = 0.0;
				joint_delta_force_ = new_force - joint_force_;
				joint_force_ = new_force;
				
				// we only publish when we have at least one subscriber to our topic
				if( pub_.getNumSubscribers() > 0 ) {
					gazebo_crab_plugin::pid_joint_state msg;
					double p, i, d, i_max, i_min;
					msg.desired = desired_value_;
					msg.value = joint_->GetAngle( 0 ).Radian();
					msg.force = new_force;
					msg.d_force = new_force - joint_force_;
					pid_.getGains( msg.pid_p, msg.pid_i, msg.pid_d, i_min, i_max );
					pid_.getCurrentPIDErrors( &msg.pid_pe, &msg.pid_ie, &msg.pid_de );
					pub_.publish( msg );
				}
				
				joint_force_ = new_force;
			}
			
			/** @brief called to update the joint state (applied force), based on the desired velocity (to reach the desired angle)
			 * 
			 * @note this code does not require constant time steps, aside the fact that gazebo does use constant
			 *       time steps for the simulation, with one exception: the damping factor depends on the step size
			 * 
			 * @todo compute damping factor, based on dt
			 */
			void update_velForce() {
				ros::Time now = ros::Time::now();					// current time
				ros::Duration dt = now - time_last_update_;			// delta time (now - last update)
				math::Angle joint_angle = joint_->GetAngle( 0 );	// assuming a rotary joint with a single axis/angle
				double current_angle = joint_angle.Radian();		// actual angle
				
				if( reset_ ) {
					parent_->resetModel();
					joint_->Reset();
					joint_->SetVelocity( 0, 0.0 );
					joint_->SetAngle( 0, 0.0 );
					reset_ = false;
				}
				
				int last_index = past_index_;
				past_index_ = (past_index_ + 1) % past_values_.size();
				past_values_[past_index_] = current_angle;
				joint_velocity_ = past_values_[past_index_] - past_values_[last_index];
				
				double d_angle = desired_value_ - current_angle;
				
				// compute our desired velocity
				//   velocity to reach the target angle with the next tick: d_angle / dt
				//   we additionally apply a damping factor, so that we would reach the desired angle in dt/damping_factor seconds (instead of dt seconds)
				double desired_velocity = velocity_damping_ * d_angle / dt.toSec();
				if( desired_velocity > joint_max_velocity_ ) {
					desired_velocity = joint_max_velocity_;
				} else if( desired_velocity < -joint_max_velocity_ ) {
					desired_velocity = -joint_max_velocity_;
				}
				
				double d_vel = desired_velocity - joint_velocity_;			// by what value we want to change the current joint velocity
				double d_force = pid_multiplier_*pid_.computeCommand( d_vel, dt );	// currection value estimate from the PID controller
				
				// compute the new force that we apply to the joint
				double new_force = joint_force_ + d_force;
				if( new_force > joint_max_force_ ) {
					new_force = joint_max_force_;
				} else if( new_force < -joint_max_force_ ) {
					new_force = -joint_max_force_;
				}
				joint_->SetForce( 0, new_force );
				
				// save some values that we might publish
				joint_angle_ = current_angle;
				joint_desired_velocity_ = desired_velocity;
				joint_delta_force_ = d_force;
				joint_force_ = new_force;
				
				// debug message
				//
				/*
				std::cout << "test  " << joint_->GetName() << std::endl;
				if( std::string("leg_1_joint_2") == joint_->GetName() ) {
					std::cout << "#### d_angle=" << d_angle << ", d_vel=" << d_vel << ", new_force=" << new_force << ", d_force=" << d_force << std::endl;
				}
				*/
				//
				// end of debug message
				
				// we only publish when we have at least one subscriber to our topic
				if( pub_.getNumSubscribers() > 0 ) {
					gazebo_crab_plugin::pid_joint_state msg;
					double p, i, d, i_max, i_min;
					msg.desired = desired_value_;
					msg.value = joint_->GetAngle( 0 ).Radian();
					msg.force = new_force;
					msg.d_force = d_force;
					pid_.getGains( msg.pid_p, msg.pid_i, msg.pid_d, i_min, i_max );
					pid_.getCurrentPIDErrors( &msg.pid_pe, &msg.pid_ie, &msg.pid_de );
					pub_.publish( msg );
				}
				
				
				if( log_file_.is_open() ) {
					// log fields: time, target_angle, current_angle, velocity, error
					log_file_ << ros::Time::now()
						<< " " << desired_value_		// target angle
						<< " " << current_angle			// actuall angle
						<< " " << joint_velocity_		// current velocity
						<< " " << (desired_value_ - current_angle)				// position error
						<< " " << (joint_velocity_ - joint_desired_velocity_)	// velocity error
						<< std::endl;
				}
			}
			
			/// @brief creates a log file and writes the header to it
			void create_file() {
				
				if( !save_to_file_ )
					return;
				
				// close the file if it is already open
				if( log_file_.is_open() ) {
					log_file_.close();
				}
				
				// create path & folders (id not already exists)
				std::string path = std::string( "/opt/shared/developer/logs/arm_test/" );
				boost::filesystem::path dir(path);
				boost::system::error_code ec;
				boost::filesystem::create_directories(dir, ec);
				if( !ec ) {
					std::cout << "failed to create directory '" << path << "', error=" << ec.message() << std::endl;
					//ROS_ERROR( "failed to create directory '%s'", path.c_str() );
				}
				
				// create the filename (p_i_d_imax_imin_m_vmax_damp_<joint>.log)
				double p,i,d,imax,imin;
				char str[256];
				pid_.getGains( p, i, d, imax, imin );
				snprintf( str, 256, "%0.4f_%0.4f_%0.4f_%0.4f_%0.4f_%0.4f_%0.4f_%0.4f_%s.log",
					p,i,d,
					imax,imin,
					pid_multiplier_,
					joint_max_velocity_,
					velocity_damping_,
					joint_->GetName().c_str()
				);
				//std::string filename = (std::string("") + (parent_->getNH()->getNamespace().c_str()+1) + "." + joint_->GetName() + ".log");
				std::string filename = std::string(str);
				
				// open the file
				log_file_.open( (path+filename).c_str(), std::ios::out );
				std::cout << "log file=" << (path+filename) << std::endl;
				
				// write the parameters to the first line (should have a higher precesion than the ones in the filename
				log_file_ << "#"
					<< " " << p
					<< " " << i
					<< " " << d
					<< " " << imax
					<< " " << imin
					<< " " << pid_multiplier_
					<< " " << joint_max_velocity_
					<< " " << velocity_damping_
					<< " " << joint_max_force_
					<< " " << joint_->GetName()
					<< std::endl;
			}
			
			/// @brief called to update the joint state according to the PID controller and the desired state
			void update() {
				if( !ready_ )
					return;
				
				if( reset_ ) {
					parent_->resetModel();
					joint_->Reset();
					joint_->SetVelocity( 0, 0.0 );
					joint_->SetAngle( 0, 0.0 );
					reset_ = false;
					// todo: reset past_values_ too
				}
				
				ros::Time now = ros::Time::now();					// current time
				ros::Duration dt = now - time_last_update_;			// delta time (now - last update)
				math::Angle joint_angle = joint_->GetAngle( 0 );	// assuming a rotary joint with a single axis/angle
				double current_angle = joint_angle.Radian();		// actual angle
				
				int last_index = past_index_;
				past_index_ = (past_index_ + 1) % past_values_.size();
				past_values_[past_index_] = current_angle;
				joint_velocity_ = past_values_[past_index_] - past_values_[last_index];
				
				double d_angle = desired_value_ - current_angle;
				
				// compute the pid output
				double pid_out;
				switch( input_type_ ) {
					default: // fall through
					case 0:
						pid_out = pid_multiplier_*pid_.computeCommand( update_input_pos(), dt );
						break;
					case 1:
						pid_out = pid_multiplier_*pid_.computeCommand( update_input_vel(), dt );
						break;
				}
				
				// compute the new force for the joint
				double new_force;
				switch( update_type_ ) {
					default:
					case 0:
						new_force = pid_out;
						// cap the applied joint force, if it is too large or too small
						if( new_force > joint_max_force_ ) {
							new_force = joint_max_force_;
						} else if( new_force < -joint_max_force_ ) {
							new_force = -joint_max_force_;
						}
						break;
				
					case 1:
						new_force = joint_force_ + pid_out;
						if( new_force > joint_max_force_ ) {
							new_force = joint_max_force_;
						} else if( new_force < -joint_max_force_ ) {
							new_force = -joint_max_force_;
						}
						break;
				}
				
				// apply the new force
				joint_->SetForce( 0, new_force );
				
				// save some values that we might publish
				joint_angle_ = current_angle;
				joint_desired_velocity_ = 0.0;
				joint_delta_force_ = new_force - joint_force_;
				joint_force_ = new_force;
				
				time_last_update_ = ros::Time::now();
				
				// we only publish when we have at least one subscriber to our topic
				if( pub_.getNumSubscribers() > 0 ) {
					gazebo_crab_plugin::pid_joint_state msg;
					double p, i, d, i_max, i_min;
					msg.desired = desired_value_;
					msg.value = joint_->GetAngle( 0 ).Radian();
					msg.force = new_force;
					msg.d_force = new_force - joint_force_;
					pid_.getGains( msg.pid_p, msg.pid_i, msg.pid_d, i_min, i_max );
					pid_.getCurrentPIDErrors( &msg.pid_pe, &msg.pid_ie, &msg.pid_de );
					pub_.publish( msg );
				}
				
				// write to joint log file
				if( log_file_.is_open() ) {
					// log fields: time, target_angle, current_angle, velocity, error
					log_file_ << ros::Time::now()
						<< " " << desired_value_		// target angle
						<< " " << current_angle			// actuall angle
						<< " " << joint_velocity_		// current velocity
						<< " " << (desired_value_ - current_angle)				// position error
						<< " " << (joint_velocity_ - joint_desired_velocity_)	// velocity error
						<< std::endl;
				}
				
				// we only publish when we have at least one subscriber to our topic
				if( pub_err_.getNumSubscribers() > 0 ) {
					gazebo_crab_plugin::pid_joint_error err_msg;
					err_msg.angle = joint_angle_;
					err_msg.angle_error = desired_value_ - joint_angle_;
					err_msg.velocity = joint_velocity_;
					err_msg.velocity_error = joint_velocity_ - joint_desired_velocity_;
					err_msg.force = joint_->GetForce(0);
					err_msg.force_delta = joint_delta_force_;
					
					pub_err_.publish( err_msg );
				}
				
				/*
				gazebo_crab_plugin::pid_joint_state msg;
				double p, i, d, i_max, i_min;
				msg.desired = desired_value_;
				msg.value = joint_->GetAngle( 0 ).Radian();
				pid_.getGains( msg.pid_p, msg.pid_i, msg.pid_d, i_min, i_max );
				pid_.getCurrentPIDErrors( &msg.pid_pe, &msg.pid_ie, &msg.pid_de );
				pub_.publish( msg );
				*/
			}
			
			
			void setVelocityDamping( double velocity_damping ) {
				velocity_damping_ = velocity_damping;
			}
			
			
			void setPidMultiplier( double pid_multiplier ) {
				pid_multiplier_ = pid_multiplier;
			}
			
			
		private:
			friend void callback( gazebo_crab_plugin::dyn_paramsConfig &config, uint32_t level, PidJoint *pid_joint );
			
			/// @brief pointer to the parent, a ModelPIDJoint object.
			ModelPIDJoint *parent_;
			
			/// @brief set to true if the controller is ready. stays false if the initialization failed
			bool ready_;
			
			/// @brief factor to adjust the output of the PID controller
			double pid_multiplier_;
			
			/// @brief the desired joint state (angle, radians)
			double desired_value_;
			
			/// @brief array (vector) containing the past view values to compute the velocity and acceleration. used as a ring buffer
			std::vector<double> past_values_;
			
			/// @brief index of the first value in past_values_
			int past_index_;
			
			/// @brief the current angle of the joint
			double joint_angle_;
			
			/// @brief current joint velocity (compute from the angle of the last update to this update)
			double joint_velocity_;
			
			/// @brief the desired velocity by the controller
			double joint_desired_velocity_;
			
			/// @brief the force that we are currently applying to the joint
			double joint_force_;
			
			/// @brief the difference of the applied force between now and the last update
			double joint_delta_force_;
			
			/// @brief the maximum joint force that we apply
			double joint_max_force_;
			
			/// @brief the maximum velocity of the joint (in rad/s). not a physical limit, just a value that we _try_ to respect
			double joint_max_velocity_;
			
			/// @brief damping factor when computing the desired joint velocity
			double velocity_damping_;
			
			/// @brief update type: 0=directForce, 1=deltaForce
			int update_type_;
			
			/// @brief controller input: 0=position, 1=velocity
			int input_type_;
			
			/// @brief if true we are resetting the joint state (angle & velocity) at the next update
			bool reset_;
			
			/// @brief timestamp of the last update
			ros::Time time_last_update_;
			
			/// @brief ros node handle
			ros::NodeHandle *nh_;
			
			/// @brief subscriber for set commands (joint position)
			ros::Subscriber sub_;
			
			/// @brief subscriber for settting parameters (because of problems with setting dynamic parameters via matlab)
			ros::Subscriber sub_param_;
			
			/// @brief publisher for joint state data
			ros::Publisher pub_;
			
			/// @brief publisher for joint error data
			ros::Publisher pub_err_;
			
			/// @brief the PID controller itself
			control_toolbox::Pid pid_;
			
			/// @brief dynamic reconfigure server
			dynamic_reconfigure::Server<gazebo_crab_plugin::dyn_paramsConfig> *dyn_reconf_server_;
			
			/// @brief the joint that we are manipulating
			gazebo::physics::Joint *joint_;
			
			/// @brief if set to true, we are writing data to a log file
			bool save_to_file_;
			
			/// @brief log file object (unused, if save_to_file_ is false)
			std::ofstream log_file_;
	};
	
	
	
	
	/// @brief dynamic reconfigure callback function for the PidJoint class
	void callback( gazebo_crab_plugin::dyn_paramsConfig &config, uint32_t level, PidJoint *pid_joint ) {
		/*
		ROS_INFO("Reconfigure Request: %f %f", 
			config.velocity_damping,
			config.pid_multiplier
		);
		*/
		
		// do nothing (for debugging)
		//return;
		
		std::cout << "dyn-config for " << pid_joint->joint_->GetName() << " loaded: [p="
			<< config.p_gain << ", i=" << config.i_gain << ", d=" << config.d_gain
			<< ", c=" << config.i_clamp_max << "/" << config.i_clamp_min
			<< ", vel_max=" << config.velocity_max
			<< ", vel_d=" << config.velocity_damping
			<< ", mult=" << config.pid_multiplier << "]"
			<< std::endl;
		
		pid_joint->joint_max_velocity_ = config.velocity_max;
		pid_joint->velocity_damping_ = config.velocity_damping;
		pid_joint->pid_multiplier_ = config.pid_multiplier;
		pid_joint->pid_.setGains( config.p_gain, config.i_gain, config.d_gain, config.i_clamp_max, config.i_clamp_min );
	}
	
	
	
	
	/// @brief called when the plugin is loaded. initializes the object
	void ModelPIDJoint::Load( physics::ModelPtr model, sdf::ElementPtr sdf ) {
		// store the pointer to the model
		model_ = model;
		sdf_ = sdf;
		
		if( sdf_->HasElement("robotNamespace") ) {
			nh_ = new ros::NodeHandle( sdf_->GetElement("robotNamespace")->Get<std::string>() );
		} else {
			ROS_INFO( "no 'robotNamespace' parameter set for the model, using default namespace" );
			nh_ = new ros::NodeHandle();
		}

		// listen to the update event. this event is broadcast every simulation iteration.
		this->update_connection_ = event::Events::ConnectWorldUpdateBegin(
			boost::bind(&ModelPIDJoint::OnUpdate, this, _1)
		);

		const gazebo::physics::Joint_V joints_vec = this->model_->GetJoints();
		
		std::cout << "joint count:" << this->model_->GetJointCount()
			<< ", id=" << this->model_->GetId()
			<< ", name=" << this->model_->GetName()
			<< ", namespace=" << nh_->getNamespace()
			<< ", robotNS=" << sdf_->GetElement("robotNamespace")->Get<std::string>()
			<< std::endl;
		
		if( !ros::isInitialized() ) {
			std::cout << "ROS is not initialized" << std::endl;
			return;
		} else {
			std::cout << "ROS is initialized" << std::endl;
		}
		
		for( int i=0; i<joints_vec.size(); i++ ) {
			// debug output
			//
			/*
			std::cout << "  joint " << (i<10?" ":"") << i << ": name=" << joints_vec[i]->GetName()
				<< ", type=" << joints_vec[i]->GetType()
				<< ", axis-count=" << joints_vec[i]->GetAngleCount()
				<< std::endl;
			*/
			//
			// end of debug output
			
			pid_joint_vec_.push_back( new PidJoint(this, *(joints_vec[i])) );
		}
		
	}

	/// @brief called by the world update start event. in this function we update the state of all joints
	void ModelPIDJoint::OnUpdate(const common::UpdateInfo & /*_info*/) {
		
		// invoke an update call for every joint that we control
		for( int i=0; i<pid_joint_vec_.size(); i++ ) {
			pid_joint_vec_[i]->update();
		}
	}
	
	
	
	// register this plugin with the simulator as model plugin
	GZ_REGISTER_MODEL_PLUGIN( ModelPIDJoint )
	
	
	
	
	
}	// end of namespace 'gazebo'




















